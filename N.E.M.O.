//******************************************************************* 
//
//      Created for N.E.M.O (NeverLAN Electronic Motion Operative)
//      Written By Zane Durkin
//      For Use on Arduino Due board.
//      created 10/25/2014
//      last edited 11/16/2014
//      
//*******************************************************************

// possible reviews
//
// change Engine stall pins to intrupt pins.
// change Encoder pins to inturrupt pins.


// Direction is 0 or 1 (low or high)
// D = digital  C = current sensing  L = left   R = right  PWD = pulse width modulation(speed) E = Encoder

// Right front will use 24, 26,54,62     26 is pwm    
//const int RFD     = 23;   //direction
//const int RFPWD   = 2;    //speed pwm2
//const int RFC     = 54;   //engine stall reciver A0
//const int RFE     = 25;   //Encoder reader 
// pins: direction, speed, stall, Encoder
int RF[]= {23, 2, 54, 25};

// Right Back will use 25, 27, 55,63    27 is pwm    
//const int RBD     = 27;    //direction
//const int RBPWD   = 3;     //speed pwm3
//const int RBC     = 55;    //engine stall reciever A1
//const int RBE     = 29;    //Encoder reader 
// pins: direction, speed, stall, Encoder
int RB[] = {27, 3, 55, 29};

// Left Front will use 32, 34, 56, 64    34 is pwm
//const int LFD     = 22;    //direction
//const int LFPWD   = 4;     //speed pwm4
//const int LFC     = 56;    //engine stall reciever A2
//const int LFE     = 24;    //Encoder reader 
// pins: direction, speed, stall, Encoder
int LF[] = {22, 4, 56, 24};

// Left Back will use 33, 35, 57, 65    35 is pwm
//const int LBD     = 26;    //direction
//const int LBPWD   = 5;     //speed pwm5
//const int LBC     = 57;    //engine stall reciever A3
//const int LBE     = 28;    //Encoder reader 
// pins: direction, speed, stall, Encoder
int LB[] = {26, 5, 57, 28};

int done = 0;            // a variable for the encoders
const int spin    = 64;  //how long motors should run to spin the robot 90 degrees (like a top)


void setup() {
  pinMode (RF[1], OUTPUT);
  pinMode (RB[1], OUTPUT);
  pinMode (LF[1], OUTPUT);
  pinMode (LB[1], OUTPUT);
  
  attachInterrupt(RF[3], checkFront, HIGH);
  attachInterrupt(RB[3], checkBack, HIGH);
  attachInterrupt(LF[3], checkFront, HIGH);
  attachInterrupt(LB[3], checkBack, HIGH);
  
  pinMode (RF[4], INPUT);
  pinMode (RB[4], INPUT);
  pinMode (LF[4], INPUT);
  pinMode (LB[4], INPUT);
  
}

void loop() {
  delay(5000);
  //go forward 4 feet at full speed 
  forward(4, 255);
  //wait 1 second
  delay (1000);
  //spin clock wise 180 degrees at full speed 
  spinCW (2, 255);
  //wait 1 second
  delay (1000);
  //spin counter-clock wise at full speed 
  spinCCW(2, 255);
  delay (3000);
  
  // draw out NEMO
  forward(4,255);
  delay(500);
  diagBR(5,255);
  delay(500);
  forward(4, 255);
  delay(1000);
  //finished with the N
  right(1, 255);
  delay(500);
  //moving over for the E
  right(2, 255);
  left(2, 255);
  delay(500);
  reverse(2, 255);
  delay(500);
  right(1, 255);
  left(1,255);
  delay(500);
  reverse(2, 255);
  delay(500);
  right(2, 255);
  left(2, 255);
  delay(1000);
  //done with the E
  right(3, 255);
  delay(500);
  //starting the M
  forward(4, 255);
  delay(500);
  diagBR(5, 255);
  delay(500);
  diagFR(5, 255);
  delay(500);
  reverse(4, 255);
  delay(10000);
  //done with the M
  right(1, 255);
  delay(500);
  //start with the O
  right(1, 255);
  diagFR(1, 255);
  forward(1, 255);
  diagFL(1, 255);
  left(1, 255);
  diagBL(1, 255);
  reverse(1, 255);
  diagBR(1, 255);
  right(1, 255);
  delay(1000);
  //done with the O
  
  
  //delay to allow people to pick up the robot, so it doesn't start the loop again.
  delay(10000);
}


//function to walk forward until encoder reaches a certain amount
//64 is the number of counts per shaft-rotation. one rotation is about 1/100 foot 
//should possibly use attachInterrupt(pin, ISR, mode)
//walk is based off front right wheel, use walkLF for other wheels




int Walk(int count=6400){
  done = 0;
  attachInterrupt(RF[4], add, HIGH);
  while(done < count){
  
  }
  detachInterrupt(RF[4]);
}
int WalkLF (int count=6400){
  done= 0;
  attachInterrupt(LF[4], add,HIGH);
  while(done < count){
  
  }
  detachInterrupt(LF[4]);
}
void add (){done++;}


//set count equal to 6400 if no variable is given
void walk (int count=6400){
  int done = 0;
  while(done < count){
    //check for a PWM pulse; when on, start timer; when off, return how long the pulse was high; is pulse was on high longer than 10 microsecounds, continue
    if (pulseIn(RF[4], HIGH)>10){
      done ++;
    }
  }
}

void walkLF (int count=6400){
  int done = 0;
  while(done < count){
    if (pulseIn(LF[4], HIGH)>10){
      done ++;
    }
  }
}

void checkFront(){
  //set all wheels to go backward
  digitalWrite(RF[1], LOW);
  digitalWrite(RB[1], LOW);
  digitalWrite(LF[1], LOW);
  digitalWrite(LB[1], LOW);
  //go backward at half speed
  analogWrite(RF[2], 127);
  analogWrite(RB[2], 127);
  analogWrite(LF[2], 127);
  analogWrite(LB[2], 127);
  //walk back for half a foot
  Walk(3200);
  //stop wheels
  analogWrite(RF[2], 0);
  analogWrite(RB[2], 0);
  analogWrite(LF[2], 0);
  analogWrite(LB[2], 0);
}

void checkBack(){
  //set all wheels to go forward
  digitalWrite(RF[1], HIGH);
  digitalWrite(RB[1], HIGH);
  digitalWrite(LF[1], HIGH);
  digitalWrite(LB[1], HIGH);
  //go backward at half speed
  analogWrite(RF[2], 127);
  analogWrite(RB[2], 127);
  analogWrite(LF[2], 127);
  analogWrite(LB[2], 127);
  //walk back for half a foot
  Walk(3200);
  //stop wheels
  analogWrite(RF[2], 0);
  analogWrite(RB[2], 0);
  analogWrite(LF[2], 0);
  analogWrite(LB[2], 0);
}

//straight forward
void forward (int distance, int spd){
  //set all wheels to go forward
  digitalWrite(RF[1], HIGH);
  digitalWrite(RB[1], HIGH);
  digitalWrite(LF[1], HIGH);
  digitalWrite(LB[1], HIGH);
  //while it still has distance to go and the wheels are not stalled, go forward. 
  while (distance > 0 && (analogRead(RF[3]) < 511 && analogRead(RB[3]) < 511 && analogRead(LF[3]) < 511 && analogRead(LB[3]) < 511)){    
    //give all wheels speed that was assigned 
    analogWrite(RF[2], spd);
    analogWrite(RB[2], spd);
    analogWrite(LF[2], spd);
    analogWrite(LB[2], spd);
    //walk until encoder input reaches 6400
  Walk();
    //subtract a foot from the distance
    distance --;
  }
  //turn off the wheels
  analogWrite(RF[2], 0);
  analogWrite(RB[2], 0);
  analogWrite(LF[2], 0);
  analogWrite(LB[2], 0);
}

//straight Back
void reverse (int distance, int spd){
  digitalWrite(RF[1], LOW);
  digitalWrite(RB[1], LOW);
  digitalWrite(LF[1], LOW);
  digitalWrite(LB[1], LOW);
  //while it still has distance to go and the wheels are not stalled, go backward. 
  while (distance > 0 && (analogRead(RF[3]) < 511 && analogRead(RB[3]) < 511 && analogRead(LF[3]) < 511 && analogRead(LB[3]) < 511)){
    //give all wheels speed that was assigned
    analogWrite(RF[2], spd);
    analogWrite(RB[2], spd);
    analogWrite(LF[2], spd);
    analogWrite(LB[2], spd);
    Walk();
    //subtract a foot from the distance
    distance --;
  } 
  //turn off the wheels
  analogWrite(RF[2], 0);
  analogWrite(RB[2], 0);
  analogWrite(LF[2], 0);
  analogWrite(LB[2], 0);
}

//moving left 
void left (int distance, int spd){
  digitalWrite(RF[1], HIGH);
  digitalWrite(RB[1], LOW);
  digitalWrite(LF[1], LOW);
  digitalWrite(LB[1], HIGH);
  //while it still has distance to go and the wheels are not stalled, do something. 
  while (distance > 0 && (analogRead(RF[3]) < 511 && analogRead(RB[3]) < 511 && analogRead(LF[3]) < 511 && analogRead(LB[3]) < 511)){
    //give all wheels speed that was assigned
    analogWrite(RF[2], spd);
    analogWrite(RB[2], spd);
    analogWrite(LF[2], spd);
    analogWrite(LB[2], spd);
    //delay()should be changed to read encoder output
    delay(spin);
    //subtract a foot from the distance
    distance --;
  }
  //turn off the wheels
  analogWrite(RF[2], 0);
  analogWrite(RB[2], 0);
  analogWrite(LF[2], 0);
  analogWrite(LB[2], 0);
}

//moving right
void right(int distance, int spd){
  digitalWrite(RF[1], LOW);
  digitalWrite(RB[1], HIGH);
  digitalWrite(LF[1], HIGH);
  digitalWrite(LB[1], LOW);
  //while it still has distance to go and the wheels are not stalled, do something. 
  while (distance > 0 && (analogRead(RF[3]) < 511 && analogRead(RB[3]) < 511 && analogRead(LF[3]) < 511 && analogRead(LB[3]) < 511)){
    //give all wheels speed that was assigned
    analogWrite(RF[2], spd);
    analogWrite(RB[2], spd);
    analogWrite(LF[2], spd);
    analogWrite(LB[2], spd);
    //delay()should be changed to read encoder output
    delay(spin);
    //subtract a foot from the distance
    distance --;
  }
  //turn off the wheels
  analogWrite(RF[2], 0);
  analogWrite(RB[2], 0);
  analogWrite(LF[2], 0);
  analogWrite(LB[2], 0);
}

//spining clockwise
void spinCW (int distance, int spd){
  digitalWrite(RF[1], LOW);
  digitalWrite(RB[1], LOW);
  digitalWrite(LF[1], HIGH);
  digitalWrite(LB[1], HIGH);
  //while it still has distance to go and the wheels are not stalled, do something. 
   while (distance > 0 && (analogRead(RF[3]) < 511 && analogRead(RB[3]) < 511 && analogRead(LF[3]) < 511 && analogRead(LB[3]) < 511)){
    //give all wheels speed that was assigned
    analogWrite(RF[2], spd);
    analogWrite(RB[2], spd);
    analogWrite(LF[2], spd);
    analogWrite(LB[2], spd);
    Walk();
    //subtract a foot from the distance
    distance --;
  }
  //turn off the wheels
  analogWrite(RF[2], 0);
  analogWrite(RB[2], 0);
  analogWrite(LF[2], 0);
  analogWrite(LB[2], 0);
}

//spinning counter-clock wise
void spinCCW(int distance, int spd){
  digitalWrite(RF[1], HIGH);
  digitalWrite(RB[1], HIGH);
  digitalWrite(LF[1], LOW);
  digitalWrite(LB[1], LOW);
  //while it still has distance to go and the wheels are not stalled, do something. 
   while (distance > 0 && (analogRead(RF[3]) < 511 && analogRead(RB[3]) < 511 && analogRead(LF[3]) < 511 && analogRead(LB[3]) < 511)){
    //give all wheels speed that was assigned
    analogWrite(RF[2], spd);
    analogWrite(RB[2], spd);
    analogWrite(LF[2], spd);
    analogWrite(LB[2], spd);
    Walk();
    //subtract a foot from the distance
    distance --;
  }
  //turn off the wheels
  analogWrite(RF[2], 0);
  analogWrite(RB[2], 0);
  analogWrite(LF[2], 0);
  analogWrite(LB[2], 0);
}

//drive diagonal forward and right
void diagFR (int distance, int spd){
  digitalWrite(RF[1], HIGH);
  digitalWrite(RB[1], HIGH);
  digitalWrite(LF[1], HIGH);
  digitalWrite(LB[1], HIGH);
  while(distance > 0 && (analogRead(RF[3]) < 511 && analogRead(RB[3]) < 511 && analogRead(LF[3]) < 511 && analogRead(LB[3]) < 511)){
    analogWrite(RF[2], 0);
    analogWrite(RB[2], spd);
    analogWrite(LF[2], spd);
    analogWrite(LB[2], 0);
    WalkLF();
    distance --;
    
  }
  analogWrite(RF[2], 0);
  analogWrite(RB[2], 0);
  analogWrite(LF[2], 0);
  analogWrite(LB[2], 0);
}

//drive diagonal Forward and left
void diagFL (int distance, int spd){
  digitalWrite(RF[1], HIGH);
  digitalWrite(RB[1], HIGH);
  digitalWrite(LF[1], HIGH);
  digitalWrite(LB[1], HIGH);
  while(distance > 0 && (analogRead(RF[3]) < 511 && analogRead(RB[3]) < 511 && analogRead(LF[3]) < 511 && analogRead(LB[3]) < 511)){
    analogWrite(RF[2], spd);
    analogWrite(RB[2], 0);
    analogWrite(LF[2], 0);
    analogWrite(LB[2], spd);
    Walk();
    distance --;
  }
  analogWrite(RF[2], 0);
  analogWrite(RB[2], 0);
  analogWrite(LF[2], 0);
  analogWrite(LB[2], 0);
}

//drive diagonal backward and right
void diagBR (int distance, int spd){
  digitalWrite(RF[1], LOW);
  digitalWrite(RB[1], LOW);
  digitalWrite(LF[1], LOW);
  digitalWrite(LB[1], LOW);
  while(distance > 0 && (analogRead(RF[3]) < 511 && analogRead(RB[3]) < 511 && analogRead(LF[3]) < 511 && analogRead(LB[3]) < 511)){
    analogWrite(RF[2], 0);
    analogWrite(RB[2], spd);
    analogWrite(LF[2], spd);
    analogWrite(LB[2], 0);
    Walk();
    distance --;
  }
  analogWrite(RF[2], 0);
  analogWrite(RB[2], 0);
  analogWrite(LF[2], 0);
  analogWrite(LB[2], 0);
}

//drive diagonal backward and left
void diagBL (int distance, int spd){
  digitalWrite(RF[1], LOW);
  digitalWrite(RB[1], LOW);
  digitalWrite(LF[1], LOW);
  digitalWrite(LB[1], LOW);
  while(distance > 0 && (analogRead(RF[3]) < 511 && analogRead(RB[3]) < 511 && analogRead(LF[3]) < 511 && analogRead(LB[3]) < 511)){
    analogWrite(RF[2], spd);
    analogWrite(RB[2], 0);
    analogWrite(LF[2], 0);
    analogWrite(LB[2], spd);
    walkLF();
    distance --;
  }
  analogWrite(RF[2], 0);
  analogWrite(RB[2], 0);
  analogWrite(LF[2], 0);
  analogWrite(LB[2], 0);
}
